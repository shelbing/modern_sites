---
/**
 * BundleModal Component
 * 
 * This component displays a modal with detailed information about a bundle offer.
 * It includes a date picker for selecting arrival and departure dates,
 * and displays availability information for the selected dates.
 */

import { renderRichText } from '@storyblok/astro';
import RichText from "../Base/RichText.astro";
import AvailabilityDisplay from "./AvailabilityDisplay.astro";
import OfferDatePicker from "./OfferDatePicker.svelte";
import AvailableRooms from './AvailableRooms.svelte';
import AvailabilityRawDebug from './AvailabilityRawDebug.svelte';
import AvailabilityLoader from './AvailabilityLoader.svelte';
import '../../../src/stores/roomStore.js';

interface Props {
  bundle: {
    _uid: string;
    Title: string;
    Beschreibung?: any;
    TeaserImage?: {
      filename?: string;
      alt?: string;
    };
    Kategorie?: string;
    AnreiseVon?: string;
    AnreiseBis?: string;
    BundleCode?: string;
    Mindestaufenthalt?: string | number;
    Categories?: string;
    Basisrate?: string;
    [key: string]: any;
  };
  id: string;
  rooms?: any[];
  services?: any[];
  minStay?: number;
}

const { id, bundle, minStay = 3, rooms = [], services = [] } = Astro.props;

// Format date if available
const formatDate = (dateString: string | undefined) => {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat("de-DE", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    }).format(date);
  } catch (e) {
    return dateString;
  }
};

// Process rich text content using Storyblok's renderRichText
let richTextContent = "";
if (bundle.Beschreibung) {
  try {
    // Handle different possible structures of the Beschreibung field
    if (typeof bundle.Beschreibung === 'object') {
      // If it's already a rich text object, use renderRichText
      if (bundle.Beschreibung.content || bundle.Beschreibung.type === 'doc') {
        richTextContent = renderRichText(bundle.Beschreibung);
      } 
      // If it's an array of content blocks
      else if (Array.isArray(bundle.Beschreibung)) {
        // Create a valid rich text structure
        const richTextObj = {
          type: 'doc',
          content: bundle.Beschreibung
        };
        richTextContent = renderRichText(richTextObj);
      }
      // If it has a nested content structure
      else if (bundle.Beschreibung.richtext) {
        richTextContent = renderRichText(bundle.Beschreibung.richtext);
      }
      // Fallback for other object structures
      else {
        console.log('Unknown rich text structure:', bundle.Beschreibung);
        // Try to convert to string if possible
        richTextContent = JSON.stringify(bundle.Beschreibung);
      }
    } 
    // If it's a string, use it directly
    else if (typeof bundle.Beschreibung === 'string') {
      richTextContent = bundle.Beschreibung;
    }
  } catch (error) {
    console.error('Error rendering rich text:', error);
    // Provide a fallback in case of error
    richTextContent = typeof bundle.Beschreibung === 'string' 
      ? bundle.Beschreibung 
      : 'Fehler beim Anzeigen der Beschreibung.';
  }
}

const validFrom = formatDate(bundle.AnreiseVon);
const validTo = formatDate(bundle.AnreiseBis);

// Process minimum stay if available from the bundle data (takes precedence over prop)
let effectiveMinStay = minStay; // Start with the prop value
if (bundle.Mindestaufenthalt) {
  // Convert to number if it's a string
  const stayValue = typeof bundle.Mindestaufenthalt === 'string' 
    ? parseInt(bundle.Mindestaufenthalt, 10) 
    : bundle.Mindestaufenthalt;
  
  // Only use valid numbers
  if (!isNaN(stayValue) && stayValue > 0) {
    effectiveMinStay = stayValue;
  }
}

const imageUrl = bundle.TeaserImage?.filename || "/images/placeholder.jpg";
---

<!-- Modal backdrop -->
<div id={id} class="fixed inset-0 z-50 flex items-center justify-center hidden overflow-auto bg-black bg-opacity-50 transition-opacity duration-300">

  <div class="relative bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-auto transition-colors duration-200">
    <!-- Modal header -->
    <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700">
      <h2 class="text-2xl font-bold text-gray-900 dark:text-white text-left">{bundle.Title}</h2>
      <button class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none" onclick="this.closest('.fixed').classList.add('hidden'); document.body.classList.remove('overflow-hidden'); if(window.setStartDate) window.setStartDate(null); if(window.setEndDate) window.setEndDate(null);">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
    
    <!-- Modal content -->
    <div class="flex-1 overflow-y-auto p-6">
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <!-- Image section -->
        <div class="relative">
          <img 
            src={imageUrl} 
            alt={bundle.TeaserImage?.alt || bundle.Title} 
            class="w-full h-auto rounded-lg object-cover"
          />
          {bundle.Kategorie && (
            <span class="absolute top-4 right-4 bg-white text-primary-600 px-3 py-1 rounded-full text-xs font-medium shadow-md">
              {bundle.Kategorie}
            </span>
          )}
          {minStay && (
            <span class="absolute top-4 left-4 bg-green-600 text-white px-3 py-1 rounded-full text-xs font-medium shadow-md">
              ab {minStay} {minStay === 1 ? 'Tag' : 'Tage'}
            </span>
          )}
          {(validFrom || validTo) && (
            <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-60 text-white px-3 py-2 text-sm">
              <span class="font-medium">Anreise:</span>
              {validFrom && validTo
                ? ` ${validFrom} - ${validTo}`
                : ` ${validFrom || validTo}`}
            </div>
          )}
        </div>
        
        <!-- Details section -->
        <div class="text-left">
          <div class="rich-text-container text-left">
            {richTextContent ? (
              <div class="font-sans rich-text text-gray-700 dark:text-gray-300 text-left" set:html={richTextContent}></div>
            ) : (
              <p class="text-gray-600 dark:text-gray-400 text-left">Keine Beschreibung verfügbar.</p>
            )}
          </div>
        </div>
      </div>
      
      <!-- Availability Display (Full Width) -->
      {bundle.Categories && (
        <div class="w-full p-4 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 text-left">
                   
          <!-- Date selection and available rooms section -->
          <div class="">
           
            <div class="mb-4 border border-gray-200 dark:border-gray-700 rounded-lg p-4 bg-white  dark:bg-gray-800">
              <div class="flex flex-wrap md:flex-nowrap gap-6 justify-between">
                <!-- Date picker column with max-width: 40% -->
                <div class="w-full md:w-2/5 max-w-[40%]">
                  <OfferDatePicker
                    client:only="svelte"
                    minArrival={new Date(bundle.AnreiseVon || new Date())}
                    maxArrival={new Date(bundle.AnreiseBis || new Date(Date.now() + 60 * 24 * 60 * 60 * 1000))}
                    minStay={minStay || 3}
                    fullyBookedDays={[]}
                    adults={2}
                    children={0}
                  />
                </div>
                        
                <!-- Loading indicator -->
                <div id={`availability-loading-${id}`} class="w-full md:w-3/5 max-w-[60%] flex justify-center items-center">
                  <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 dark:border-white"></div>
                </div>
                
                <!-- Available rooms container (hidden initially) -->
                <div id={`available-rooms-container-${id}`} class="w-full md:w-3/5 max-w-[60%] hidden">
                  <!-- This div will be populated by the AvailableRooms component -->
                  <AvailableRooms
                    client:only="svelte"
                    bundleData={JSON.stringify(bundle)}
                    roomsData={JSON.stringify(rooms)}
                    servicesData={JSON.stringify(services)}
                    showRoomDebug={true}
                  />
                  
                  
                </div>
                
                <!-- Add the AvailabilityLoader component to handle data loading using Svelte -->
                <AvailabilityLoader
                  client:only="svelte"
                  id={id}
                  bundleData={JSON.stringify(bundle)}
                  roomsData={JSON.stringify(rooms)}
                  servicesData={JSON.stringify(services)}
                />
              </div>
            </div>
          </div>
            
            <div id={`availability-dates-${id}`} class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-3 mt-2">
              <!-- Availability data will be inserted here by JavaScript -->
            </div>
          </div>         
     
      )}
    </div>
    
    <!-- Modal footer -->
    <div class="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end items-center">
      <button class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-medium py-2 px-4 rounded" onclick="this.closest('.fixed').classList.add('hidden'); document.body.classList.remove('overflow-hidden'); if(window.setStartDate) window.setStartDate(null); if(window.setEndDate) window.setEndDate(null);">
        Schließen
      </button>
    </div>
  </div>
</div>

<script>
  import { setStartDate, setEndDate } from '../../../src/stores/roomStore.js';
  if (typeof window !== 'undefined') {
    window.setStartDate = setStartDate;
    window.setEndDate = setEndDate;
  }
</script>
<script define:vars={{ id: id, bundle: bundle }}>
  // Load the modal manager script only on the client-side
  // The typeof check prevents SSR errors
  if (typeof window !== 'undefined') {
    // We'll dynamically import the script
    import('../../../src/scripts/modalManager.js')
      .then(() => {
        console.log('Modal manager loaded in BundleModal');
      })
      .catch(err => console.error('Error loading modal manager:', err));
  }
  
  // Local modal variables
  const modal = document.getElementById(id);
  
  document.addEventListener('DOMContentLoaded', () => {
    // Find all Svelte AvailabilityLoader components and update their visibility
    document.addEventListener('bundleModalShown', (event) => {
      if (event.detail && event.detail.id === id) {
        console.log(`Modal ${id} shown - notifying Svelte components`);
        
        // Update any Svelte components - they'll handle the rest
        // This is a fallback in case the props don't update automatically
        const event = new CustomEvent('availabilityModalShown', { detail: { id } });
        document.dispatchEvent(event);
      }
    });

    // Helper function to format date for API (YYYY-MM-DD)
    function formatDateForAPI(date) {
      const d = new Date(date);
      return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    }
    
    // Function to display availability data
    function displayAvailabilityData(availabilityData) {
      const availabilityContainer = document.getElementById(`availability-container-${id}`);
      const loadingElement = document.getElementById(`availability-loading-${id}`);
      const datesContainer = document.getElementById(`availability-dates-${id}`);
      const totalAvailabilityElement = document.getElementById(`total-availability-${id}`);
      const dateFilterSelect = document.getElementById(`date-filter-${id}`);
      
      if (!availabilityContainer || !datesContainer) return;
      
      // Store the data globally for filtering
      globalAvailabilityData = availabilityData;
      
      // Hide loading indicator and show availability container
      if (loadingElement) loadingElement.classList.add('hidden');
      availabilityContainer.classList.remove('hidden');
      
      // Clear previous content
      datesContainer.innerHTML = '';
      
      // Get the category codes from the bundle
      const categoryCodes = bundle.Categories.split(',').map(cat => cat.trim());
      
      // Sort availability data by date
      availabilityData.sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Calculate total availability across all dates
      const totalAvailability = availabilityData.reduce((sum, dateEntry) => sum + dateEntry.totalSellableCount, 0);
      
      // Display total availability
      if (totalAvailabilityElement) {
        totalAvailabilityElement.textContent = `${totalAvailability} Zimmer verfügbar`;
      }
      
      // Set up date range calendar with Flatpickr date pickers
      const dateFromInput = document.getElementById(`date-from-${id}`);
      const dateToInput = document.getElementById(`date-to-${id}`);
      const applyButton = document.getElementById(`date-filter-apply-${id}`);
      const resetButton = document.getElementById(`date-filter-reset-${id}`);
      
      if (dateFromInput && dateToInput && applyButton && resetButton) {
        // Get AnreiseVon and AnreiseBis dates from the bundle
        let bundleStartDate = null;
        let bundleEndDate = null;
        
        if (bundle.AnreiseVon) {
          bundleStartDate = new Date(bundle.AnreiseVon);
        }
        
        if (bundle.AnreiseBis) {
          bundleEndDate = new Date(bundle.AnreiseBis);
        }
        
        // Find min and max dates in the availability data
        let minDate = null;
        let maxDate = null;
        
        // Create an array of valid dates (within AnreiseVon to AnreiseBis range)
        const validDates = [];
        
        availabilityData.forEach(dateEntry => {
          const currentDate = new Date(dateEntry.date);
          
          // Check if this date is within bundle's arrival range
          let isValidDate = true;
          if (bundleStartDate && bundleEndDate) {
            isValidDate = currentDate >= bundleStartDate && currentDate <= bundleEndDate;
          }
          
          if (isValidDate) {
            validDates.push(dateEntry.date);
          }
          
          // Still track min/max for overall range
          if (!minDate || currentDate < minDate) {
            minDate = currentDate;
          }
          if (!maxDate || currentDate > maxDate) {
            maxDate = currentDate;
          }
        });
        
        // Format dates for input fields (YYYY-MM-DD)
        const formatDateForInput = (date) => {
          if (!date) return null;
          
          // If date is a string with time component (e.g., "2025-12-22 00:00"), remove the time part
          if (typeof date === 'string' && date.includes(' ')) {
            return date.split(' ')[0];
          }
          
          // If it's a Date object, convert to ISO and take only the date part
          if (date instanceof Date) {
            return date.toISOString().split('T')[0];
          }
          
          // If it's already in the correct format, return as is
          return date;
        };
        
        // Store valid dates for filtering and pass to the date picker
        window.validDatesForModal = window.validDatesForModal || {};
        window.validDatesForModal[id] = validDates;
        
        // We'll determine fully booked days later when initializing the date picker
        
        // Find the earliest available date in the data
        let earliestAvailableDate = null;
        if (validDates.length > 0) {
          // Sort the valid dates to find the earliest
          const sortedDates = [...validDates].sort((a, b) => new Date(a) - new Date(b));
          earliestAvailableDate = new Date(sortedDates[0]);
        } else if (minDate) {
          earliestAvailableDate = new Date(minDate);
        } else if (bundle.AnreiseVon) {
          earliestAvailableDate = new Date(bundle.AnreiseVon);
        }
        
        // Calculate departure date (arrival date + 3 days minimum stay)
        let departureDate = null;
        if (earliestAvailableDate) {
          departureDate = new Date(earliestAvailableDate);
          departureDate.setDate(departureDate.getDate() + 3); // Add 3 days for minimum stay
          
          // Make sure departure date is not after the max date
          if (maxDate && departureDate > maxDate) {
            departureDate = new Date(maxDate);
          }
          
          // Make sure departure date is not after bundle end date
          if (bundle.AnreiseBis && departureDate > new Date(bundle.AnreiseBis)) {
            departureDate = new Date(bundle.AnreiseBis);
          }
        }
        
        console.log('[DEBUG] Fully booked days:', fullyBookedDays);
        
        console.log('[DEBUG] Starting OfferDatePicker initialization');
        console.log('[DEBUG] Bundle ID:', id);
        console.log('[DEBUG] Container selector:', `#date-picker-container-${id}`);
        
        // Add a visual indicator that we're trying to load the component
        const datePickerContainer = document.getElementById(`date-picker-container-${id}`);
        if (datePickerContainer) {
          datePickerContainer.innerHTML = '<div style="padding: 10px; background-color: #f0f0f0; border: 1px dashed #999;">Loading date picker...</div>';
          console.log('[DEBUG] Added loading indicator to container');
        } else {
          console.error('[DEBUG] Container not found before import');
        }
        
        // Try alternative import approaches
        console.log('[DEBUG] Attempting to import OfferDatePicker component');
        
        // Use dynamic import with the correct path
        try {
          console.log('[DEBUG] Trying to import OfferDatePicker component');
          // Use the correct path format for Astro's client-side imports
          import('/src/components/offers/OfferDatePicker.svelte')
            .then(module => {
              console.log('[DEBUG] Import successful, module:', module);
              const OfferDatePicker = module.default;
              console.log('[DEBUG] OfferDatePicker component:', OfferDatePicker);
              
              if (typeof OfferDatePicker === 'function') {
                initializeComponent(OfferDatePicker);
              } else {
                console.error('[DEBUG] OfferDatePicker is not a constructor:', OfferDatePicker);
                if (datePickerContainer) {
                  datePickerContainer.innerHTML = '<div style="padding: 10px; background-color: #ffeeee; border: 1px solid #ff0000;">Invalid component format</div>';
                }
              }
            })
            .catch(error => {
              console.error('[DEBUG] Import failed:', error);
              console.error('[DEBUG] Error stack:', error.stack);
              
              // Try alternative path as fallback
              console.log('[DEBUG] Trying alternative import path');
              import('./OfferDatePicker.svelte')
                .then(module => {
                  console.log('[DEBUG] Alternative import successful');
                  initializeComponent(module.default);
                })
                .catch(error2 => {
                  console.error('[DEBUG] All import attempts failed');
                  if (datePickerContainer) {
                    datePickerContainer.innerHTML = `
                      <div style="padding: 10px; background-color: #ffeeee; border: 1px solid #ff0000;">
                        <p>Failed to load date picker component</p>
                        <p>Error: ${error.message}</p>
                        <button onclick="window.location.reload()" class="px-3 py-1 mt-2 bg-blue-500 text-white rounded">
                          Reload page
                        </button>
                      </div>`;
                  }
                });
            });
        } catch (outerError) {
          console.error('[DEBUG] Exception during import attempts:', outerError);
          if (datePickerContainer) {
            datePickerContainer.innerHTML = '<div style="padding: 10px; background-color: #ffeeee; border: 1px solid #ff0000;">Error loading component</div>';
          }
        }
        
        // Helper function to initialize the component
        function initializeComponent(OfferDatePickerComponent) {
          console.log('[DEBUG] Initializing component with:', {
            minArrival,
            maxArrival,
            minStay,
            fullyBookedDays: fullyBookedDays.length
          });
          
          // Get the container again in case the DOM has changed
          const container = document.getElementById(`date-picker-container-${id}`);
          if (!container) {
            console.error('[DEBUG] Container not found during initialization');
            return;
          }
          
          // Clear the loading indicator
          container.innerHTML = '';
          
          try {
            console.log('[DEBUG] Creating component instance');
            const datePicker = new OfferDatePickerComponent({
              target: container,
              props: {
                minArrival: minArrival,
                maxArrival: maxArrival,
                minStay: minStay,
                fullyBookedDays: fullyBookedDays
              }
            });
            
            console.log('[DEBUG] Component instance created successfully');
            
            // Store the date picker instance for later reference
            window.offerDatePickers = window.offerDatePickers || {};
            window.offerDatePickers[id] = datePicker;
            
            // Listen for selection events from the date picker
            datePicker.$on('selection', (event) => {
              console.log('[DEBUG] Selection event received:', event.detail);
              const { arrival, departure } = event.detail;
              
              if (arrival) {
                selectedFromDate = formatDateForInput(arrival);
                console.log('[DEBUG] Selected arrival date:', selectedFromDate);
              }
              
              if (departure) {
                selectedToDate = formatDateForInput(departure);
                console.log('[DEBUG] Selected departure date:', selectedToDate);
              }
              
              // Apply the filter with the selected date range if both dates are selected
              if (selectedFromDate && selectedToDate) {
                console.log('[DEBUG] Filtering availability with date range:', selectedFromDate, 'to', selectedToDate);
                filterAvailabilityByDateRange(selectedFromDate, selectedToDate);
              }
            });
            
            // Set initial dates if available
            if (earliestAvailableDate) {
              const initialArrival = earliestAvailableDate;
              const initialDeparture = new Date(initialArrival);
              initialDeparture.setDate(initialDeparture.getDate() + minStay);
              
              console.log('[DEBUG] Setting initial dates:', initialArrival, 'to', initialDeparture);
              datePicker.$set({
                arrival: initialArrival,
                departure: initialDeparture
              });
              
              selectedFromDate = formatDateForInput(initialArrival);
              selectedToDate = formatDateForInput(initialDeparture);
              
              // Apply the initial filter
              console.log('[DEBUG] Applying initial filter with dates:', selectedFromDate, 'to', selectedToDate);
              filterAvailabilityByDateRange(selectedFromDate, selectedToDate);
            }
          } catch (error) {
            console.error('[DEBUG] Error during component initialization:', error);
            console.error('[DEBUG] Error stack:', error.stack);
            container.innerHTML = '<div style="padding: 10px; background-color: #ffeeee; border: 1px solid #ff0000;">Error initializing date picker</div>';
          }
        }
        
        // Add event listeners for the apply and reset buttons
        applyButton.addEventListener('click', function() {
          if (selectedFromDate && selectedToDate) {
            filterAvailabilityByDateRange(selectedFromDate, selectedToDate);
          }
        });
        
        resetButton.addEventListener('click', function() {
          if (minDate && maxDate) {
            // Reset to the full date range
            const minDateStr = formatDateForInput(minDate);
            const maxDateStr = formatDateForInput(maxDate);
            
            // Update the date pickers
            if (window.updateDatePicker) {
              window.updateDatePicker(`date-from-${id}`, { 
                minDate: bundle.AnreiseVon || minDateStr,
                maxDate: bundle.AnreiseBis || maxDateStr,
                validDates: validDates
              });
              
              window.updateDatePicker(`date-to-${id}`, { 
                minDate: bundle.AnreiseVon || minDateStr,
                maxDate: bundle.AnreiseBis || maxDateStr,
                validDates: validDates
              });
            }
            
            // Reset selected dates
            selectedFromDate = bundle.AnreiseVon || minDateStr;
            selectedToDate = bundle.AnreiseBis || maxDateStr;
            
            // Filter with the full date range
            filterAvailabilityByDateRange(selectedFromDate, selectedToDate);
          }
        });
        
        // Update date pickers with the calculated initial dates
        if (window.updateDatePicker) {
          if (selectedFromDate) {
            window.updateDatePicker(`date-from-${id}`, { 
              defaultDate: selectedFromDate,
              minDate: bundle.AnreiseVon || (minDate ? formatDateForInput(minDate) : null),
              maxDate: bundle.AnreiseBis || (maxDate ? formatDateForInput(maxDate) : null)
            });
          }
          
          if (selectedToDate) {
            window.updateDatePicker(`date-to-${id}`, { 
              defaultDate: selectedToDate,
              minDate: selectedFromDate, // Ensure departure date is after arrival
              maxDate: bundle.AnreiseBis || (maxDate ? formatDateForInput(maxDate) : null)
            });
          }
        }
        
        // Set up initial filter with the selected date range
        if (selectedFromDate && selectedToDate) {
          // Initial filter with the selected date range
          setTimeout(() => {
            filterAvailabilityByDateRange(selectedFromDate, selectedToDate);
          }, 500);
        } else if (minDate && maxDate) {
          const minDateStr = formatDateForInput(minDate);
          const maxDateStr = formatDateForInput(maxDate);
          
          // Initial filter with the full date range as fallback
          setTimeout(() => {
            filterAvailabilityByDateRange(minDateStr, maxDateStr);
          }, 500);
        }
      }
      
      // We'll display dates after the date pickers are initialized
      // The initial filter will be applied by the date picker initialization
    }
    
    // Function to filter availability data by date range
    function filterAvailabilityByDateRange(fromDate, toDate) {
      if (!fromDate || !toDate || !globalAvailabilityData || globalAvailabilityData.length === 0) {
        return;
      }
      
      console.log(`Filtering availability from ${fromDate} to ${toDate}`);
      
      // Convert string dates to Date objects for comparison
      const fromDateObj = new Date(fromDate);
      const toDateObj = new Date(toDate);
      
      // Filter the data to only include dates within the range
      const filteredData = globalAvailabilityData.filter(day => {
        const dayDate = new Date(day.date);
        return dayDate >= fromDateObj && dayDate <= toDateObj;
      });
      
      // Display the filtered data
      displayAvailabilityData(filteredData);
      
      // Update the selected date range display
      const dateRangeElement = document.getElementById(`selected-date-range-${id}`);
      if (dateRangeElement) {
        // Format dates for display (DD.MM.YYYY)
        const formatDisplayDate = (dateStr) => {
          const date = new Date(dateStr);
          return date.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric' });
        };
        
        dateRangeElement.textContent = `${formatDisplayDate(fromDate)} - ${formatDisplayDate(toDate)}`;
      }
      
      // Render the filtered cards
      renderAvailabilityCards(filteredData, categoryCodes, datesContainer);
    }
    
    // Function to render availability cards
    function renderAvailabilityCards(data, categoryCodes, container) {
      // Create a card for each date with availability information
      data.forEach(dateEntry => {
        // Format the date for display
        const dateObj = new Date(dateEntry.date);
        const formattedDate = dateObj.toLocaleDateString('de-DE', {
          weekday: 'short',
          day: '2-digit',
          month: '2-digit',
          year: 'numeric'
        });
        
        // Create a card for this date
        const dateCard = document.createElement('div');
        dateCard.className = 'bg-white dark:bg-gray-700 rounded-lg shadow-sm p-3 border border-gray-200 dark:border-gray-600';
        dateCard.dataset.date = dateEntry.date; // Store the date for filtering
        
        // Create date header
        const dateHeader = document.createElement('div');
        dateHeader.className = 'font-medium text-gray-800 dark:text-gray-200 mb-2';
        dateHeader.textContent = formattedDate;
        
        // Create availability count
        const availabilityCount = document.createElement('div');
        availabilityCount.className = 'text-green-600 dark:text-green-400 font-medium text-lg';
        availabilityCount.textContent = `${dateEntry.totalSellableCount} verfügbar`;
        
        // Create unit groups list
        const unitGroupsList = document.createElement('div');
        unitGroupsList.className = 'mt-2 text-sm';
        
        // Filter unit groups to only include those in the bundle's categories
        const relevantUnitGroups = dateEntry.unitGroups.filter(group => 
          categoryCodes.includes(group.code));
        
        // Add each unit group
        relevantUnitGroups.forEach(group => {
          const unitGroupItem = document.createElement('div');
          unitGroupItem.className = 'flex justify-between items-center text-gray-600 dark:text-gray-300';
          
          const unitGroupName = document.createElement('span');
          unitGroupName.textContent = group.code;
          
          const unitGroupCount = document.createElement('span');
          unitGroupCount.className = group.sellableCount > 0 ? 'text-green-500' : 'text-red-500';
          unitGroupCount.textContent = group.sellableCount;
          
          unitGroupItem.appendChild(unitGroupName);
          unitGroupItem.appendChild(unitGroupCount);
          unitGroupsList.appendChild(unitGroupItem);
        });
        
        // Assemble the card
        dateCard.appendChild(dateHeader);
        dateCard.appendChild(availabilityCount);
        dateCard.appendChild(unitGroupsList);
        
        // Add the card to the container
        container.appendChild(dateCard);
      });
    }
    
    // Function to handle modal opening
    function handleModalOpen() {
      if (!modal.classList.contains('hidden')) {
        checkRoomAvailability();
      }
    }
    
    // Add a MutationObserver to detect when the modal becomes visible
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class' && !modal.classList.contains('hidden')) {
          checkRoomAvailability();
        }
      });
    });
    
    observer.observe(modal, { attributes: true });
    
    // Close modal when clicking on close buttons
    // Define the hideModal function
    function hideModal() {
      if (!modal) return; // Safety check
      modal.classList.add('hidden');
      document.body.classList.remove('overflow-hidden');
    }
    
    // Set up close buttons
    const closeButtons = modal.querySelectorAll('.modal-close');
    closeButtons.forEach(button => {
      button.addEventListener('click', hideModal);
    });
  });
    
    // Close modal when clicking outside of it
    modal.addEventListener('click', (event) => {
      if (event.target === modal) {
        modal.classList.add('hidden');
        document.body.classList.remove('overflow-hidden');
        // Clear dates in the store
        if(window.setStartDate) window.setStartDate(null);
        if(window.setEndDate) window.setEndDate(null);
        // Hide rooms container
        const availableRoomsContainer = document.getElementById(`available-rooms-container-${id}`);
        if (availableRoomsContainer) availableRoomsContainer.classList.add('hidden');
      }
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && !modal.classList.contains('hidden')) {
        modal.classList.add('hidden');
        document.body.classList.remove('overflow-hidden');
        // Clear dates in the store
        if(window.setStartDate) window.setStartDate(null);
        if(window.setEndDate) window.setEndDate(null);
        // Hide rooms container
        const availableRoomsContainer = document.getElementById(`available-rooms-container-${id}`);
        if (availableRoomsContainer) availableRoomsContainer.classList.add('hidden');
      }
    });
  });
  
  // Setup date picker event listener
  function setupDatePickerEvents() {
    document.addEventListener('dateSelection', async (e) => {
      console.log('Date selection event received:', e.detail);
      const detail = e.detail;
      
      // Get the loading indicator and rooms container
      const loadingIndicator = document.getElementById(`availability-loading-${id}`);
      const availableRoomsContainer = document.getElementById(`available-rooms-container-${id}`);
      
      if (detail.complete && detail.arrival && detail.departure) {
        // Both dates are selected, just filter the data in the store (no API fetch)
        console.log(`Selected date range: ${detail.arrival} to ${detail.departure}`);
        if (loadingIndicator) loadingIndicator.classList.add('hidden');
        if (availableRoomsContainer) availableRoomsContainer.classList.remove('hidden');
        // Import the filterRoomDataByDateRange function from the store
        const { filterRoomDataByDateRange, loadRoomsData, loadServicesData, setCurrentBundle } = await import('../../../src/stores/roomStore.js');
        filterRoomDataByDateRange(detail.arrival, detail.departure);
        
        // Load additional data to the store if available - with extra debug
        console.log('[DEBUG] Date selection complete - loading store data');
        
        // Force create arrays if undefined
        if (typeof window.hotelRooms === 'undefined' || window.hotelRooms === null) window.hotelRooms = [];
        if (typeof window.hotelServices === 'undefined' || window.hotelServices === null) window.hotelServices = [];
        
        // Explicitly clone arrays to avoid reference issues
        const rooms = [...(window.hotelRooms || [])];
        const services = [...(window.hotelServices || [])];
        
        console.log('[DEBUG] Loading data to store:', {
          rooms: rooms.length, 
          services: services.length,
          bundle: window.currentBundle ? 'available' : 'not set'
        });
        
        loadRoomsData(rooms);
        loadServicesData(services);
        if (window.currentBundle) setCurrentBundle(window.currentBundle);
      } else {
        // Hide available rooms when dates are not complete
        if (availableRoomsContainer) availableRoomsContainer.classList.add('hidden');
        if (loadingIndicator) loadingIndicator.classList.remove('hidden');
      }
    });
  }
  
  function initializeModal() {
    const modal = document.getElementById(id);
    if (!modal) return;
    
    // Get all open buttons that target this modal
    const openButtons = document.querySelectorAll(`[data-modal-target="${id}"]`);
    const closeButtons = modal.querySelectorAll('.modal-close');
    
    // Add click event to open buttons
    openButtons.forEach(button => {
      button.addEventListener('click', () => {
        modal.classList.remove('hidden');
        document.body.classList.add('overflow-hidden');
        
        // Reset the store dates first
        // Use a safer approach to access dynamically added window properties
        if(typeof window['setStartDate'] === 'function') window['setStartDate'](null);
        if(typeof window['setEndDate'] === 'function') window['setEndDate'](null);
        
        // Immediately load all data into the store
        const storeFunctions = await import('../../../src/stores/roomStore.js');
        
        // Make this bundle accessible globally for debug (no need to use window.bundle)
        console.log('[DEBUG] Making bundle available globally');
        window.currentBundle = bundle;
        
        // Set the current bundle in the store
        if (storeFunctions.setCurrentBundle) {
          console.log('[DEBUG] Setting current bundle in store:', bundle.Title);
          storeFunctions.setCurrentBundle(bundle);
        }
        
        // Log what global data we have available
        console.log('[DEBUG] Global data check:', {
          hotelRooms: window.hotelRooms ? window.hotelRooms.length + ' items' : 'not set',
          hotelServices: window.hotelServices ? window.hotelServices.length + ' items' : 'not set',
          currentBundle: window.currentBundle ? 'set' : 'not set'
        });
        
        // Set global data and load it into the store - with specific check for null/undefined
        if (typeof window.hotelRooms === 'undefined' || window.hotelRooms === null) {
          console.log('[DEBUG] No global rooms data found, creating empty array');
          window.hotelRooms = [];
        }
        
        // FORCE create arrays if still undefined (double-check after previous step)
        if (typeof window.hotelRooms === 'undefined' || window.hotelRooms === null) window.hotelRooms = [];
        if (typeof window.hotelServices === 'undefined' || window.hotelServices === null) window.hotelServices = [];
        
        // Load the data into the store - with explicit cloning to avoid reference issues
        if (storeFunctions.loadRoomsData) {
          const rooms = [...(window.hotelRooms || [])];
          console.log('[DEBUG] Loading rooms data into store:', rooms.length, 'items');
          storeFunctions.loadRoomsData(rooms);
        }
        
        if (storeFunctions.loadServicesData) {
          const services = [...(window.hotelServices || [])];
          console.log('[DEBUG] Loading services data into store:', services.length, 'items');
          storeFunctions.loadServicesData(services);
        }
        
        // Force bundle into store as well
        if (storeFunctions.setCurrentBundle) {
          console.log('[DEBUG] Force setting bundle again to ensure update');
          storeFunctions.setCurrentBundle({...bundle});
        }
        
        // Hide rooms container when opening (until dates are selected)
        const availableRoomsContainer = document.getElementById(`available-rooms-container-${id}`);
        if (availableRoomsContainer) availableRoomsContainer.classList.add('hidden');
        
        // Check room availability when opening the modal
        checkRoomAvailability();
        
        // Re-setup date picker events when modal opens
        setTimeout(() => {
          setupDatePickerEvents();
          
          // Reinitialize the date picker with this bundle's constraints
          if (window.offerDatePickers && window.offerDatePickers[id]) {
            try {
              const datePicker = window.offerDatePickers[id];
              // Update the date picker's constraints based on this offer's dates
              datePicker.$set({
                minArrival: new Date(bundle.AnreiseVon || new Date()),
                maxArrival: new Date(bundle.AnreiseBis || new Date(Date.now() + 60 * 24 * 60 * 60 * 1000)),
                minStay: bundle.Mindestaufenthalt ? parseInt(bundle.Mindestaufenthalt) : 3,
                arrival: null,
                departure: null
              });
              console.log('[DEBUG] Date picker reinitialized for bundle:', bundle.Title);
            } catch (e) {
              console.error('[DEBUG] Error reinitializing date picker:', e);
            }
          }
        }, 500);
      });
    });
    
    // Add click event to close buttons
    closeButtons.forEach(button => {
      button.addEventListener('click', () => {
        modal.classList.add('hidden');
        document.body.classList.remove('overflow-hidden');
      });
    });
    
    // Close modal when clicking outside the content
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.add('hidden');
        document.body.classList.remove('overflow-hidden');
      }
    });
  }
  
  // Add a MutationObserver to detect when the modal becomes visible
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class' && !modal.classList.contains('hidden')) {
        checkRoomAvailability();
      }
    });
  });
  
  observer.observe(modal, { attributes: true });
  
  // Initialize modal functionality
  initializeModal();
  
  // Check room availability when the page loads
  checkRoomAvailability();
  
  // Setup date picker event listener
  setTimeout(() => {
    setupDatePickerEvents();
  }, 500);
</script>

<script>
  // Handle adults and children changes from the OfferDatePicker
  document.addEventListener('DOMContentLoaded', () => {
    const datePicker = document.querySelector('.offer-date-picker');
    if (datePicker) {
      // Listen for custom events from the OfferDatePicker
      datePicker.addEventListener('adultsChange', (event) => {
        // Create a custom event to pass to the AvailableRooms component
        const customEvent = new CustomEvent('adultsChange', {
          detail: event.detail,
          bubbles: true
        });
        document.dispatchEvent(customEvent);
      });
      
      datePicker.addEventListener('childrenChange', (event) => {
        // Create a custom event to pass to the AvailableRooms component
        const customEvent = new CustomEvent('childrenChange', {
          detail: event.detail,
          bubbles: true
        });
        document.dispatchEvent(customEvent);
      });
    }
  });
</script>

<style>
  /* Base paragraph styling */
  .rich-text :global(p) {
    margin-bottom: 1.5rem !important;
    line-height: 1.6;
    text-align: left;
  }
  
  .rich-text :global(p:last-child) {
    margin-bottom: 0;
  }
  
  /* Date picker styling */
  .date-picker {
    position: relative;
  }
  
  /* Text formatting */
  .rich-text :global(strong), .rich-text :global(b) {
    font-weight: 600;
  }
  
  .rich-text :global(em), .rich-text :global(i) {
    font-style: italic;
  }
  
  /* Lists */
  .rich-text :global(ul), .rich-text :global(ol) {
    margin-bottom: 1.5rem !important;
    padding-left: 1.5rem;
    list-style-position: outside;
  }
  
  .rich-text :global(ul) {
    list-style-type: disc;
  }
  
  .rich-text :global(ol) {
    list-style-type: decimal;
  }
  
  .rich-text :global(li) {
    margin-bottom: 0.5rem;
    line-height: 1.5;
  }
  
  .rich-text :global(li:last-child) {
    margin-bottom: 0;
  }
  
  /* Headings */
  .rich-text :global(h1), .rich-text :global(h2), .rich-text :global(h3),
  .rich-text :global(h4), .rich-text :global(h5), .rich-text :global(h6) {
    margin-top: 1.5rem;
    margin-bottom: 1rem;
    font-weight: 600;
    line-height: 1.3;
    color: inherit;
  }
  
  .rich-text :global(h1) { font-size: 1.75rem; }
  .rich-text :global(h2) { font-size: 1.5rem; }
  .rich-text :global(h3) { font-size: 1.25rem; }
  .rich-text :global(h4) { font-size: 1.125rem; }
  .rich-text :global(h5), .rich-text :global(h6) { font-size: 1rem; }
  
  /* Links */
  .rich-text :global(a) {
    color: #4f46e5; /* indigo-600 */
    text-decoration: underline;
    transition: color 0.2s ease;
  }
  
  .rich-text :global(a:hover) {
    color: #4338ca; /* indigo-700 */
  }
  
  /* Container */
  .rich-text-container {
    margin-bottom: 1.5rem;
    overflow-wrap: break-word;
    word-wrap: break-word;
  }
  
  /* Blockquotes */
  .rich-text :global(blockquote) {
    margin: 1.5rem 0;
    padding: 0.5rem 0 0.5rem 1.5rem;
    border-left: 4px solid #e5e7eb; /* gray-200 */
    font-style: italic;
  }
  
  /* Code blocks */
  .rich-text :global(pre), .rich-text :global(code) {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size: 0.9em;
    background-color: #f3f4f6; /* gray-100 */
    border-radius: 0.25rem;
  }
  
  .rich-text :global(pre) {
    margin: 1.5rem 0;
    padding: 1rem;
    overflow-x: auto;
  }
  
  .rich-text :global(code) {
    padding: 0.2rem 0.4rem;
  }
  
  /* Tables */
  .rich-text :global(table) {
    width: 100%;
    margin: 1.5rem 0;
    border-collapse: collapse;
  }
  
  .rich-text :global(th), .rich-text :global(td) {
    padding: 0.5rem;
    border: 1px solid #e5e7eb; /* gray-200 */
    text-align: left;
  }
  
  .rich-text :global(th) {
    background-color: #f9fafb; /* gray-50 */
    font-weight: 600;
  }
  
  /* Dark mode adjustments */
  @media (prefers-color-scheme: dark) {
    .rich-text :global(blockquote) {
      border-left-color: #4b5563; /* gray-600 */
    }
    
    .rich-text :global(pre), .rich-text :global(code) {
      background-color: #1f2937; /* gray-800 */
    }
    
    .rich-text :global(th), .rich-text :global(td) {
      border-color: #4b5563; /* gray-600 */
    }
    
    .rich-text :global(th) {
      background-color: #374151; /* gray-700 */
    }
    
    .rich-text :global(a) {
      color: #818cf8; /* indigo-400 */
    }
    
    .rich-text :global(a:hover) {
      color: #a5b4fc; /* indigo-300 */
    }
  }
</style>
